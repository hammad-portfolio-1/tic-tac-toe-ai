<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Tic-Tac-Toe vs AI</title>
    <style>
        :root {
            /* default = dark theme variables */
            --bg-dark: #020617;
            --bg-card: #020617;
            --bg-cell: #0b1120;
            --bg-cell-hover: #111827;
            --border-cell: #1f2937;
            --x-color: #38bdf8;   /* cyan */
            --o-color: #f97316;   /* orange */
            --text-muted: #9ca3af;
            --text-main: #e5e7eb;
        }

        body {
            font-family: Arial, sans-serif;
            background:
                radial-gradient(circle at top, #1e293b 0, #020617 55%, #000 100%);
            color: var(--text-main);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        /* Light theme overrides */
        body.theme-light {
            --bg-dark: #e5e7eb;
            --bg-card: #f9fafb;
            --bg-cell: #ffffff;
            --bg-cell-hover: #f3f4f6;
            --border-cell: #d1d5db;
            --x-color: #0ea5e9;
            --o-color: #f97316;
            --text-muted: #4b5563;
            --text-main: #111827;

            background:
                radial-gradient(circle at top, #e5e7eb 0, #f1f5f9 60%, #e5e7eb 100%);
        }

        h1 {
            margin-bottom: 6px;
            letter-spacing: 0.05em;
        }

        h1 span {
            background: linear-gradient(90deg, #38bdf8, #a855f7, #f97316);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        #status {
            margin-bottom: 15px;
            font-size: 1.1rem;
            color: var(--text-muted);
        }

        #board {
            position: relative; /* needed for win line */
            display: grid;
            grid-template-columns: repeat(3, 100px);
            grid-template-rows: repeat(3, 100px);
            gap: 8px;
            padding: 18px;
            border-radius: 16px;
            background: radial-gradient(circle at top, var(--bg-card), var(--bg-card), #000);
            box-shadow:
                0 20px 40px rgba(15, 23, 42, 0.9),
                0 0 20px rgba(56, 189, 248, 0.1);
        }

        body.theme-light #board {
            box-shadow:
                0 20px 40px rgba(148, 163, 184, 0.7),
                0 0 20px rgba(125, 211, 252, 0.2);
        }

        .cell {
            width: 100px;
            height: 100px;
            background: var(--bg-cell);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.6rem;
            cursor: pointer;
            user-select: none;
            border: 1px solid var(--border-cell);
            transition:
                transform 0.12s ease,
                background 0.12s ease,
                box-shadow 0.12s ease,
                border-color 0.12s ease;
        }

        .cell:hover {
            transform: translateY(-2px) scale(1.03);
            background: var(--bg-cell-hover);
            box-shadow: 0 0 12px rgba(148, 163, 184, 0.3);
            border-color: #38bdf8;
        }

        .cell.disabled {
            cursor: default;
            opacity: 0.9;
            box-shadow: none;
            border-color: var(--border-cell);
        }

        /* X and O colors */
        .cell.x {
            color: var(--x-color);
            text-shadow: 0 0 12px rgba(56, 189, 248, 0.7);
        }

        .cell.o {
            color: var(--o-color);
            text-shadow: 0 0 12px rgba(249, 115, 22, 0.7);
        }

        /* placed animation */
        .cell.placed {
            box-shadow: 0 0 18px rgba(56, 189, 248, 0.8);
            transform: translateY(-1px) scale(1.06);
        }

        #controls {
            margin-top: 16px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            justify-content: center;
            background: rgba(15, 23, 42, 0.85);
            padding: 8px 14px;
            border-radius: 999px;
            box-shadow: 0 10px 25px rgba(15, 23, 42, 0.6);
        }

        body.theme-light #controls,
        body.theme-light #scoreboard {
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 10px 25px rgba(148, 163, 184, 0.5);
        }

        label {
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        select, button {
            padding: 6px 12px;
            border-radius: 999px;
            border: none;
            font-size: 0.9rem;
            outline: none;
        }

        select {
            background: #020617;
            color: var(--text-main);
            border: 1px solid #334155;
        }

        body.theme-light select {
            background: #ffffff;
            border-color: #d1d5db;
        }

        button {
            cursor: pointer;
            background: linear-gradient(90deg, #38bdf8, #a855f7);
            color: white;
            font-weight: 500;
            box-shadow: 0 8px 20px rgba(56, 189, 248, 0.4);
            transition: transform 0.12s ease, box-shadow 0.12s ease;
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 12px 26px rgba(56, 189, 248, 0.5);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 4px 10px rgba(56, 189, 248, 0.3);
        }

        #themeBtn {
            background: linear-gradient(90deg, #f97316, #22c55e);
            box-shadow: 0 8px 20px rgba(249, 115, 22, 0.4);
        }

        /* ðŸ”¥ Screen bloom overlay */
        #flashOverlay {
            position: fixed;
            inset: 0;
            pointer-events: none;
            opacity: 0;
            z-index: 999;
        }

        body.game-win #flashOverlay {
            animation: flashWin 0.7s ease-out forwards;
            background:
                radial-gradient(circle at center,
                    rgba(34, 197, 94, 0.9) 0,
                    rgba(34, 197, 94, 0.3) 35%,
                    transparent 70%);
        }

        body.game-lose #flashOverlay {
            animation: flashLose 0.7s ease-out forwards;
            background:
                radial-gradient(circle at center,
                    rgba(248, 113, 113, 0.9) 0,
                    rgba(248, 113, 113, 0.3) 35%,
                    transparent 70%);
        }

        body.game-draw #flashOverlay {
            animation: flashDraw 0.7s ease-out forwards;
            background:
                radial-gradient(circle at center,
                    rgba(129, 140, 248, 0.9) 0,
                    rgba(129, 140, 248, 0.3) 35%,
                    transparent 70%);
        }

        @keyframes flashWin {
            0%   { opacity: 0.9; transform: scale(0.9); }
            100% { opacity: 0;   transform: scale(1.3); }
        }

        @keyframes flashLose {
            0%   { opacity: 0.9; transform: scale(0.9); }
            100% { opacity: 0;   transform: scale(1.3); }
        }

        @keyframes flashDraw {
            0%   { opacity: 0.9; transform: scale(0.9); }
            100% { opacity: 0;   transform: scale(1.3); }
        }

        /* ðŸŒˆ winning line overlay */
        #winLine {
            position: absolute;
            top: 50%;
            left: 50%;
            height: 6px;
            width: 0;
            border-radius: 999px;
            background: linear-gradient(90deg, #22c55e, #a855f7);
            box-shadow: 0 0 14px rgba(34, 197, 94, 0.8);
            opacity: 0;
            transform-origin: center center;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
            transition:
                opacity 0.2s ease,
                width 0.2s ease,
                transform 0.2s ease;
        }

        #board.show-win-line #winLine {
            opacity: 1;
        }

        /* Confetti */
        #confetti {
            position: fixed;
            inset: 0;
            pointer-events: none;
            overflow: hidden;
            z-index: 998;
        }

        .confetti-piece {
            position: absolute;
            width: 8px;
            height: 14px;
            border-radius: 2px;
            top: -10%;
            opacity: 0.9;
            animation-name: confetti-fall;
            animation-timing-function: ease-out;
            animation-fill-mode: forwards;
        }

        @keyframes confetti-fall {
            0% {
                transform: translateY(0) rotateZ(0deg);
            }
            100% {
                transform: translateY(120vh) rotateZ(360deg);
            }
        }

        /* Scoreboard */
        #scoreboard {
            margin-top: 12px;
            display: flex;
            gap: 14px;
            font-size: 0.9rem;
            background: rgba(15, 23, 42, 0.85);
            padding: 6px 16px;
            border-radius: 999px;
            box-shadow: 0 10px 25px rgba(15, 23, 42, 0.6);
            color: var(--text-muted);
        }

        #scoreboard span strong {
            color: var(--text-main);
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>

    <h1><span>Tic-Tac-Toe vs AI</span></h1>
    <div id="status">Your turn (X)</div>

    <div id="board"></div>

    <div id="controls">
        <label for="modeSelect">Mode:</label>
        <select id="modeSelect">
            <option value="ai" selected>Vs AI</option>
            <option value="human">Two Players</option>
        </select>

        <label for="difficultySelect" id="difficultyLabel">Difficulty:</label>
        <select id="difficultySelect">
            <option value="easy">Easy</option>
            <option value="medium" selected>Medium</option>
            <option value="hard">Impossible</option>
        </select>

        <button id="resetBtn">Restart Game</button>
        <button id="themeBtn">Light theme</button>
    </div>

    <div id="scoreboard">
        <span>X wins: <strong id="scoreX">0</strong></span>
        <span>O wins: <strong id="scoreO">0</strong></span>
        <span>Draws: <strong id="scoreDraw">0</strong></span>
    </div>

    <!-- Overlay for bloom effect -->
    <div id="flashOverlay"></div>
    <!-- Confetti container -->
    <div id="confetti"></div>

    <script>
        // --- Global game state variables ---
        let board = Array(9).fill(null);  // 0-8 cells
        let currentPlayer = "X";          // human = X, AI = O or P1/P2
        let isGameOver = false;
        let difficulty = "medium";        // easy | medium | hard
        let gameMode = "ai";              // "ai" | "human"
        let winningCombo = null;          // stores [a, b, c] indexes for win line

        // scoreboard
        let scoreX = 0;
        let scoreO = 0;
        let scoreDraw = 0;

        // audio
        let audioCtx = null;

        function getAudioCtx()
        {
            if (!audioCtx) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (AudioContext) {
                    audioCtx = new AudioContext();
                }
            }
            return audioCtx;
        }

        function playTone(freq, duration)
        {
            const ctx = getAudioCtx();
            if (!ctx) return;

            const osc = ctx.createOscillator();
            const gain = ctx.createGain();

            osc.frequency.value = freq;
            osc.type = "sine";

            osc.connect(gain);
            gain.connect(ctx.destination);

            const now = ctx.currentTime;
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration);

            osc.start(now);
            osc.stop(now + duration);
        }

        function playClickSound() { playTone(500, 0.07); }
        function playWinSound()   { playTone(900, 0.18); }
        function playLoseSound()  { playTone(220, 0.2); }
        function playDrawSound()  { playTone(350, 0.15); }

        // --- Initialize the board and event listeners ---
        function startGame()
        {
            board = Array(9).fill(null);
            currentPlayer = "X";
            isGameOver = false;
            winningCombo = null;

            document.body.classList.remove("game-win", "game-lose", "game-draw");

            const boardDiv = document.getElementById("board");
            boardDiv.classList.remove("show-win-line");
            const winLine = document.getElementById("winLine");
            if (winLine) {
                winLine.style.width = "0px";
            }

            if (gameMode === "ai") {
                updateStatus("Your turn (X)");
            } else {
                updateStatus("Player X's turn");
            }

            renderBoard();
        }

        // --- Update status text on the page ---
        function updateStatus(message)
        {
            const statusDiv = document.getElementById("status");
            statusDiv.textContent = message;
        }

        // --- Draw the 3x3 grid based on board[] ---
        function renderBoard()
        {
            const boardDiv = document.getElementById("board");
            boardDiv.innerHTML = "";

            board.forEach((value, index) => {
                const cellDiv = document.createElement("div");
                cellDiv.classList.add("cell");
                if (value !== null) {
                    cellDiv.classList.add("disabled");
                }

                if (value === "X") cellDiv.classList.add("x");
                if (value === "O") cellDiv.classList.add("o");

                cellDiv.textContent = value ? value : "";
                cellDiv.dataset.index = index;

                cellDiv.addEventListener("click", handleCellClick);

                boardDiv.appendChild(cellDiv);
            });

            // ensure winLine element exists inside board
            let winLine = document.getElementById("winLine");
            if (!winLine) {
                winLine = document.createElement("div");
                winLine.id = "winLine";
            }
            boardDiv.appendChild(winLine);
        }

        // --- Handle when the human clicks a cell ---
        function handleCellClick(event)
        {
            if (isGameOver) {
                return;
            }

            const cellIndex = parseInt(event.target.dataset.index);

            // ignore if already filled
            if (board[cellIndex] !== null) {
                return;
            }

            // Human move (either vs AI or vs Human)
            makeMove(cellIndex, currentPlayer);

            const resultAfterMove = checkWinner(board);
            if (resultAfterMove !== null) {
                endGame(resultAfterMove);
                return;
            }

            if (gameMode === "ai") {
                // AI turn (small delay so it feels natural)
                setTimeout(() => {
                    makeAiMove();
                }, 350);
            } else {
                // vs human: switch players
                currentPlayer = currentPlayer === "X" ? "O" : "X";
                updateStatus(`Player ${currentPlayer}'s turn`);
            }
        }

        // --- Place a move on the board ---
        function makeMove(cellIndex, player)
        {
            if (board[cellIndex] === null && !isGameOver) {
                board[cellIndex] = player;
                renderBoard();

                // glow effect on placed cell
                const boardDiv = document.getElementById("board");
                const cellDiv = boardDiv.querySelector(`[data-index="${cellIndex}"]`);
                if (cellDiv) {
                    cellDiv.classList.add("placed");
                    setTimeout(() => {
                        cellDiv.classList.remove("placed");
                    }, 250);
                }

                playClickSound();
            }
        }

        // --- Helper: get empty positions ---
        function getEmptyIndices(currentBoard)
        {
            return currentBoard
                .map((value, index) => value === null ? index : null)
                .filter(index => index !== null);
        }

        // --- EASY AI: random move ---
        function getRandomMove(currentBoard)
        {
            const empty = getEmptyIndices(currentBoard);
            if (empty.length === 0) return null;
            const randomIndex = empty[Math.floor(Math.random() * empty.length)];
            return randomIndex;
        }

        // --- MEDIUM AI: win > block > center > corner > random ---
        function getMediumMove(currentBoard)
        {
            const empty = getEmptyIndices(currentBoard);

            // 1) Can AI win this move?
            for (const idx of empty) {
                const copy = [...currentBoard];
                copy[idx] = "O";
                if (checkWinner(copy) === "O") {
                    return idx;
                }
            }

            // 2) Need to block human win?
            for (const idx of empty) {
                const copy = [...currentBoard];
                copy[idx] = "X";
                if (checkWinner(copy) === "X") {
                    return idx; // block
                }
            }

            // 3) Take center if free
            if (empty.includes(4)) {
                return 4;
            }

            // 4) Take any corner if free
            const corners = [0, 2, 6, 8].filter(i => empty.includes(i));
            if (corners.length > 0) {
                return corners[Math.floor(Math.random() * corners.length)];
            }

            // 5) Otherwise random
            return getRandomMove(currentBoard);
        }

        // --- HARD AI: minimax (perfect play) ---
        function getHardMove(currentBoard)
        {
            const bestMove = minimax(currentBoard, "O");
            return bestMove.index;
        }

        function minimax(newBoard, player)
        {
            const empty = getEmptyIndices(newBoard);
            const winner = checkWinner(newBoard);

            if (winner === "X") {
                return { score: -10 };
            } else if (winner === "O") {
                return { score: 10 };
            } else if (empty.length === 0) {
                return { score: 0 };
            }

            const moves = [];

            for (const i of empty) {
                const move = {};
                move.index = i;

                // make move
                newBoard[i] = player;

                const result = minimax(newBoard, player === "O" ? "X" : "O");
                move.score = result.score;

                // undo move
                newBoard[i] = null;

                moves.push(move);
            }

            let bestMoveIndex = 0;

            if (player === "O") { // maximize
                let bestScore = -Infinity;
                for (let i = 0; i < moves.length; i++) {
                    if (moves[i].score > bestScore) {
                        bestScore = moves[i].score;
                        bestMoveIndex = i;
                    }
                }
            } else { // minimize
                let bestScore = Infinity;
                for (let i = 0; i < moves.length; i++) {
                    if (moves[i].score < bestScore) {
                        bestScore = moves[i].score;
                        bestMoveIndex = i;
                    }
                }
            }

            return moves[bestMoveIndex];
        }

        // --- Decide which AI to use based on difficulty ---
        function makeAiMove()
        {
            if (isGameOver) {
                return;
            }

            let aiMoveIndex = null;

            if (difficulty === "easy") {
                aiMoveIndex = getRandomMove(board);
            } else if (difficulty === "medium") {
                aiMoveIndex = getMediumMove(board);
            } else {
                aiMoveIndex = getHardMove(board); // impossible
            }

            if (aiMoveIndex === null) return;

            makeMove(aiMoveIndex, "O");

            const resultAfterAi = checkWinner(board);
            if (resultAfterAi !== null) {
                endGame(resultAfterAi);
            } else {
                updateStatus("Your turn (X)");
            }
        }

        // --- Check for winner or draw ---
        function checkWinner(currentBoard)
        {
            // reset; will be set if a real win is found
            winningCombo = null;

            const winningCombos = [
                [0, 1, 2],
                [3, 4, 5],
                [6, 7, 8],
                [0, 3, 6],
                [1, 4, 7],
                [2, 5, 8],
                [0, 4, 8],
                [2, 4, 6]
            ];

            // Check X or O
            for (const [a, b, c] of winningCombos) {
                if (
                    currentBoard[a] &&
                    currentBoard[a] === currentBoard[b] &&
                    currentBoard[a] === currentBoard[c]
                ) {
                    winningCombo = [a, b, c]; // save for win line
                    return currentBoard[a];   // "X" or "O"
                }
            }

            // Check draw
            if (currentBoard.every(cell => cell !== null)) {
                return "draw";
            }

            // No winner yet
            return null;
        }

        // --- Draw winning line across three winning cells ---
        function drawWinLine()
        {
            if (!winningCombo) return;

            const boardDiv = document.getElementById("board");
            const cells = boardDiv.querySelectorAll(".cell");
            const winLine = document.getElementById("winLine");
            if (!winLine) return;

            // use first and third cell of combo
            const [a, , c] = winningCombo;
            const rectA = cells[a].getBoundingClientRect();
            const rectC = cells[c].getBoundingClientRect();
            const boardRect = boardDiv.getBoundingClientRect();

            const x1 = rectA.left + rectA.width / 2 - boardRect.left;
            const y1 = rectA.top + rectA.height / 2 - boardRect.top;
            const x2 = rectC.left + rectC.width / 2 - boardRect.left;
            const y2 = rectC.top + rectC.height / 2 - boardRect.top;

            const length = Math.hypot(x2 - x1, y2 - y1);
            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
            const centerX = (x1 + x2) / 2;
            const centerY = (y1 + y2) / 2;

            winLine.style.width = length + "px";
            winLine.style.left = centerX + "px";
            winLine.style.top = centerY + "px";
            winLine.style.transform = `translate(-50%, -50%) rotate(${angle}deg)`;

            boardDiv.classList.add("show-win-line");
        }

        // --- Confetti ---
        function startConfetti()
        {
            const container = document.getElementById("confetti");
            container.innerHTML = "";
            const colors = ["#22c55e", "#38bdf8", "#f97316", "#eab308", "#a855f7", "#f472b6"];

            const pieces = 80;
            for (let i = 0; i < pieces; i++) {
                const piece = document.createElement("div");
                piece.classList.add("confetti-piece");
                piece.style.left = Math.random() * 100 + "%";
                piece.style.backgroundColor = colors[i % colors.length];
                piece.style.animationDuration = (1 + Math.random() * 0.6) + "s";
                piece.style.opacity = 0.7 + Math.random() * 0.3;
                container.appendChild(piece);
            }

            setTimeout(() => {
                container.innerHTML = "";
            }, 1600);
        }

        // --- Scoreboard update ---
        function updateScoreboard(result)
        {
            if (result === "X") scoreX++;
            else if (result === "O") scoreO++;
            else if (result === "draw") scoreDraw++;

            document.getElementById("scoreX").textContent = scoreX;
            document.getElementById("scoreO").textContent = scoreO;
            document.getElementById("scoreDraw").textContent = scoreDraw;
        }

        // --- Handle end of the game ---
        function endGame(result)
        {
            isGameOver = true;

            updateScoreboard(result);

            if (gameMode === "ai") {
                if (result === "X") {
                    updateStatus("You win! ðŸŽ‰");
                    document.body.classList.add("game-win");
                    startConfetti();
                    playWinSound();
                } else if (result === "O") {
                    updateStatus("AI wins! ðŸ¤–");
                    document.body.classList.add("game-lose");
                    playLoseSound();
                } else {
                    updateStatus("It's a draw ðŸ˜");
                    document.body.classList.add("game-draw");
                    playDrawSound();
                }
            } else {
                if (result === "X") {
                    updateStatus("Player X wins! ðŸŽ‰");
                    document.body.classList.add("game-win");
                    startConfetti();
                    playWinSound();
                } else if (result === "O") {
                    updateStatus("Player O wins! ðŸŽ‰");
                    document.body.classList.add("game-win");
                    startConfetti();
                    playWinSound();
                } else {
                    updateStatus("It's a draw ðŸ˜");
                    document.body.classList.add("game-draw");
                    playDrawSound();
                }
            }

            if (result === "X" || result === "O") {
                // small timeout so DOM layout is ready
                setTimeout(drawWinLine, 50);
            }
        }

        // --- Setup controls and start first game ---
        const resetBtn = document.getElementById("resetBtn");
        const difficultySelect = document.getElementById("difficultySelect");
        const difficultyLabel = document.getElementById("difficultyLabel");
        const modeSelect = document.getElementById("modeSelect");
        const themeBtn = document.getElementById("themeBtn");

        resetBtn.addEventListener("click", startGame);

        difficultySelect.addEventListener("change", (event) => {
            difficulty = event.target.value;
            startGame();
        });

        modeSelect.addEventListener("change", (event) => {
            gameMode = event.target.value;

            if (gameMode === "human") {
                difficultyLabel.classList.add("hidden");
                difficultySelect.classList.add("hidden");
            } else {
                difficultyLabel.classList.remove("hidden");
                difficultySelect.classList.remove("hidden");
            }

            startGame();
        });

        themeBtn.addEventListener("click", () => {
            if (document.body.classList.contains("theme-light")) {
                document.body.classList.remove("theme-light");
                themeBtn.textContent = "Light theme";
            } else {
                document.body.classList.add("theme-light");
                themeBtn.textContent = "Dark theme";
            }
        });

        // Start when page loads
        startGame();
    </script>
</body>
</html>